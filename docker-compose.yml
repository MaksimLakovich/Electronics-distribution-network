# Указываем версию формата файла docker-compose, а не версию Python.
# Она определяет какие возможности YAML доступны (например, поддержка depends_on, healthcheck, profiles и т.д.).
# Версия 3.9 - наиболее стабильная версия схемы Compose.
# Сейчас вообще можно не указывать version, потому что новый Docker Compose (v2) сам подбирает нужный формат.
version: "3.9"

# Описываем сервисы (контейнеры), которые нужны для проекта. Список сервисов = контейнеров (каждый блок под ним = отдельный контейнер).
services:

  # Django-приложение
  web:
#    build: .                          # Собираем образ из Dockerfile в корне проекта. Можно вместо этой строки указать "image: electronics_distribution_network_project" (использовать уже готовый образ, который ранее собрали руками с помощью "docker build -t my-django-app ."). Или можно как тут указать build: . (тогда compose сам вызовет docker build и соберет образ по твоему Dockerfile).
    image: ${DOCKER_HUB_USERNAME}/electronics_distribution_network:latest
    container_name: electronics_distribution_network_web     # Имя контейнера (для удобства)
    command: sh /electronics_distribution_network_project/entrypoint.sh
#    command: sh -c "python manage.py migrate && python manage.py collectstatic --noinput && gunicorn config.wsgi:application --bind 0.0.0.0:8000"  # Миграция и запуск приложения
    volumes:
      - .:/electronics_distribution_network_project                 # Монтируем локальный проект внутрь контейнера
      - media_data:/electronics_distribution_network_project/media  # Отдельный том для медиафайлов (чтобы они не терялись при пересборке)
      - static_volume:/electronics_distribution_network_project/staticfiles  # Отдельный том для статики - будет нужен, если появится фронт
    ports:
      - "8003:8000"                   # Пробрасываем порт (localhost:8003 → контейнер:8000) / 8001 и 8002 уже заняты другими приложениями
    env_file:
      - .env.docker                   # Загружаем переменные окружения из .env.docker (.env используется для локального запуска - специально разделил)

    depends_on:
      - db                            # Запускаем только после старта Postgres
    restart: always                   # Перезапускаем контейнер если упал

  # Nginx
  nginx:
    build:                                                    # Собираем образ для Nginx
      context: ./nginx                                        # Контекст сборки = папка nginx (там Dockerfile + конфиг)
    ports:
      - "8082:80"                                             # Пробрасываем порт 80 (HTTP) наружу (внешний 8082 → внутренний 80) / 8082 уже занят другим приложением
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf              # Монтируем наш конфиг внутрь контейнера
      - static_volume:/electronics_distribution_network_project/staticfiles     # Том для статики, чтобы nginx видел собранные файлы - будет нужен, если появится фронт
    depends_on:
      - web                                                   # Запускаем nginx только после Django

  # PostgreSQL база данных
  db:
    image: postgres:16                # Используем готовый официальный образ Postgres
    container_name: electronics_distribution_network_db
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Данные хранятся в отдельном томе
    env_file:
      - .env.docker                   # Подтягиваем переменные окружения из .env.docker (.env используется для локального запуска - специально разделил)
    ports:
      - "5442:5432"                   # Делаем доступным Postgres (внешний 5442 → внутренний 5432) / 5441 уже занят другим приложением
    restart: always

  # Redis
  redis:
    image: redis:7                    # Берем официальный Redis
    container_name: electronics_distribution_network_redis
    volumes:
      - redis_data:/data              # Том для хранения данных Redis (иначе все потеряется при пересборке)
    env_file:
      - .env.docker
    ports:
      - "6392:6379"                   # Открываем порт (внешний 6392 → внутренний 6379) / 6391 уже занят другим приложением
    restart: always

# Определяем именованные тома (для хранения данных вне контейнера)
volumes:
  postgres_data:    # для БД Postgres
  media_data:       # для медиафайлов Django (загруженные пользователями картинки/файлы)
  static_volume:    # для собранных статических файлов (чтобы nginx их видел) - это на будущее для фронта
  redis_data:       # для Redis (заменил redis_volume на redis_data ради единообразия)
